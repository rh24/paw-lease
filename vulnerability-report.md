# Vulnerability-Report

## Encryption
### Exposure

Encryption is critical for protecting and securing sensistive user information such as passwords and credit card information. In our application, we use ASP.NET Core Identity's hashing algorithm in order to encrypt user's passwords. This is to prevent storing passwords as plain text in the database.

Users often do not follow safe security measures, opting to reuse passwords across all their accounts. If a hacker gains access to both a user's password and e-mail, the hacker could gain access to almost every other account (financial assets, credit reports, personal & work emails) a user might have, as these days, providing two-factor authentication by e-mailing a security code is quite common. This would be truly disastrous.

### Repair

As a baseline, the entire application contains this vulnerability without ASP.NET Core Identity's encryption methods. However, a user will be jeopardized upon initial registration in `Register.cshtml`. This view contains an input field for the user to type in their password. After the user hits submit, their plain text password is carried to the `AccountController.Register()` action via a Data Transfer Object `RegisterAccount`. This object holds the plain text password but is never persisted to the database.

Within the `Register()` action in the account controller is where Identity's password hashing is called upon. If the user inputs valid fields, a new `ApplicationUser` is initialized. The `UserManager<ApplicationUser>` service provides a `CreateAsync(ApplicationUser user, string password)` method that takes care of hashing the plain text password provided by the user. This ensures that only an encrypted version will be stored in the Identity database.

```
            if (ModelState.IsValid)
            {
                CheckUserRolesExist();

                ApplicationUser newUser = new ApplicationUser()
                {
                    UserName = ra.Email,
                    FirstName = ra.FirstName,
                    LastName = ra.LastName,
                    Email = ra.Email,
                    AccountCreation = ra.AccountCreation,
                    Address = ra.Address,
                    Birthday = ra.Birthday,
                    LovesCats = ra.LovesCats
                };

                var result = await _userManager.CreateAsync(newUser, ra.Password);

				...
			}
```

## App Configuration
### Exposure

It's important to keep the application secrets, keys, and environment variables in a file that is never exposed outside of the developer's local machine. Connection strings for applications often hold sensitive data, such as passwords.

### Repair

A `DefaultConnection` string that doesn't require a password is provided in the `applicationsettings.json` file. This connection string is meant to connect to a local database. However, when wanting to connect to a production database, the sensitive credentials can be stored in a `secrets.json` file that contains application secrets. This can range from API Keys to Azure production secrets.

I will not paste a snippet of what this application's `secrets.json` file looks like because that would defeat the purpose of hiding the environment variables in a super secret file that never gets uploaded to the cloud.

However, determining which connection string to use in the `secrets.json` file is evident in the `Startup.ConfigureServices()` method.

```
            services.AddDbContext<ProductDBContext>(options =>
            options.UseSqlServer(Configuration.GetConnectionString("ProdDB")));

            services.AddDbContext<ApplicationDbContext>(options =>
            options.UseSqlServer(Configuration.GetConnectionString("ProdIdentityDB")));

```

The public never sees the "ProdDB" and "ProdIdentityDB" connection strings. These values are extracted from a locked down configuration file.

## SQL Injection
### Exposure

SQL Injection is a code injection technique used to attack applications that are data-driven. It is normally done by writing SQL commands into an entry field. This can be done through the forms itself, or possibly the URL.

This vulnerability would expose all of our data and to the user. This includes sensitive information about the products, sales, and even the user information.

### Repair

Essentially this is an issue throughout our site whenever we access any databases. However, entity framework helps prevents most sql injections as we do not have to use SQL to query the database. We essentially just call the methods on the services and query the database using C#.

This can be seen in thecode snippet below that queries a database without using SQL statements.

```
            return await _context.Carts
                .Include(c => c.LineItems)
                .ThenInclude(li => li.Product)
                .OrderByDescending(c => c.ID)
                .Take(10)
                .Where(c => c.LineItems.Count > 0 && c.OrderFulfilled == true)
                .ToListAsync();
```

## SQL Injection
### Exposure

SQL Injection is a code injection technique used to attack applications that are data-driven. It is normally done by writing SQL commands into an entry field. This can be done through the forms itself, or possibly the URL.

This vulnerability would expose all of our data and to the user. This includes sensitive information about the products, sales, and even the user information.

### Repair

Essentially this is an issue throughout our site whenever we access any databases. However, entity framework helps prevents most sql injections as we do not have to use SQL to query the database. We essentially just call the methods on the services and query the database using C#.

This can be seen in the code snippet below that queries a database without using SQL statements.

```
            return await _context.Carts
                .Include(c => c.LineItems)
                .ThenInclude(li => li.Product)
                .OrderByDescending(c => c.ID)
                .Take(10)
                .Where(c => c.LineItems.Count > 0 && c.OrderFulfilled == true)
                .ToListAsync();
```

Another solution would be to sanitize the inputs.